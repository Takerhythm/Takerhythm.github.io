<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="排序,">










<meta name="description" content="比较排序&amp;emsp;1.冒泡排序简单直观的排序算法,即相邻的元素比较大小,大的元素放后边,小的放前边123456789101112131415import randomdef bubble_sort(nums):    for j in range(len(nums)-1, 0, -1):        for i in range(j):            if nums[i] &amp;gt;">
<meta name="keywords" content="排序">
<meta property="og:type" content="article">
<meta property="og:title" content="基本排序算法">
<meta property="og:url" content="http://yoursite.com/2019/03/09/基本排序算法/index.html">
<meta property="og:site_name" content="rhythm&#39;s blog">
<meta property="og:description" content="比较排序&amp;emsp;1.冒泡排序简单直观的排序算法,即相邻的元素比较大小,大的元素放后边,小的放前边123456789101112131415import randomdef bubble_sort(nums):    for j in range(len(nums)-1, 0, -1):        for i in range(j):            if nums[i] &amp;gt;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/03/09/基本排序算法/bubble_sort.png">
<meta property="og:image" content="http://yoursite.com/2019/03/09/基本排序算法/selection_sort.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/09/基本排序算法/insertion_sort.gif">
<meta property="og:image" content="http://yoursite.com/2019/03/09/基本排序算法/shell_sort.gif">
<meta property="og:image" content="http://yoursite.com/2019/03/09/基本排序算法/quick_sort.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/09/基本排序算法/merge_sort.gif">
<meta property="og:image" content="http://yoursite.com/2019/03/09/基本排序算法/heap_sort.gif">
<meta property="og:image" content="http://yoursite.com/2019/03/09/基本排序算法/counting_sort.gif">
<meta property="og:image" content="http://yoursite.com/2019/03/09/基本排序算法/radix_sort.gif">
<meta property="og:image" content="http://yoursite.com/2019/03/09/基本排序算法/bucket_sort.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/09/基本排序算法/sort.png">
<meta property="og:updated_time" content="2019-03-12T08:23:27.075Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基本排序算法">
<meta name="twitter:description" content="比较排序&amp;emsp;1.冒泡排序简单直观的排序算法,即相邻的元素比较大小,大的元素放后边,小的放前边123456789101112131415import randomdef bubble_sort(nums):    for j in range(len(nums)-1, 0, -1):        for i in range(j):            if nums[i] &amp;gt;">
<meta name="twitter:image" content="http://yoursite.com/2019/03/09/基本排序算法/bubble_sort.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/09/基本排序算法/">





  <title>基本排序算法 | rhythm's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">rhythm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/09/基本排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="takerhythm">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhythm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">基本排序算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-09T11:08:39+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<h1 id="比较排序"><a href="#比较排序" class="headerlink" title="比较排序"></a>比较排序</h1><h2 id="emsp-1-冒泡排序"><a href="#emsp-1-冒泡排序" class="headerlink" title="&emsp;1.冒泡排序"></a>&emsp;1.冒泡排序</h2><p>简单直观的排序算法,即相邻的元素比较大小,大的元素放后边,小的放前边<br><img src="/2019/03/09/基本排序算法/bubble_sort.png" alt="bubble_sort"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def bubble_sort(nums):</span><br><span class="line">    for j in range(len(nums)-1, 0, -1):</span><br><span class="line">        for i in range(j):</span><br><span class="line">            if nums[i] &gt; nums[i+1]:</span><br><span class="line">                nums[i], nums[i+1] = nums[i+1], nums[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    nums = [random.randint(0, 1000) for i in range(10)]</span><br><span class="line">    print(nums)</span><br><span class="line">    bubble_sort(nums)</span><br><span class="line">    print(nums)</span><br></pre></td></tr></table></figure></p>
<h2 id="emsp-2-选择排序"><a href="#emsp-2-选择排序" class="headerlink" title="&emsp;2.选择排序"></a>&emsp;2.选择排序</h2><p>类似冒泡排序,但交换次数少,冒泡排序在最坏情况下,所有元素共交换(n+1)n/2次,选择排序每个元素至多只交换一次<br><img src="/2019/03/09/基本排序算法/selection_sort.jpg" alt="selection_sort"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def selection_sort(nums):</span><br><span class="line">    n = len(nums)</span><br><span class="line">    for i in range(n-1):</span><br><span class="line">        min_index = i</span><br><span class="line">        for j in range(i+1, n):</span><br><span class="line">            if nums[min_index] &gt; nums[j]:</span><br><span class="line">                min_index = j</span><br><span class="line">        if min_index != i:</span><br><span class="line">            nums[min_index], nums[i] = nums[i], nums[min_index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    nums = [random.randint(0, 1000) for i in range(10)]</span><br><span class="line">    print(nums)</span><br><span class="line">    selection_sort(nums)</span><br><span class="line">    print(nums)</span><br></pre></td></tr></table></figure></p>
<h2 id="emsp-3-插入排序"><a href="#emsp-3-插入排序" class="headerlink" title="&emsp;3.插入排序"></a>&emsp;3.插入排序</h2><p>将数组分成两部分,左侧为有序序列,右侧为无序序列,遍历无序序列,与有序序列的元素逐个比较大小,放置合适的位置,有序序列便达到了向后挪位,为新元素提供空间的效果<br><img src="/2019/03/09/基本排序算法/insertion_sort.gif" alt="insertion_sort"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def insert_sort(nums_list):</span><br><span class="line">    for j in range(1, len(nums_list)):</span><br><span class="line">        cur = nums_list[j]</span><br><span class="line">        i = j-1</span><br><span class="line">        while i &gt;= 0 and nums_list[i] &gt; cur:</span><br><span class="line">            nums_list[i], nums_list[i+1] = nums_list[i+1], nums_list[i]</span><br><span class="line">            i -= 1</span><br><span class="line">    return nums_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    nums = [random.randint(0, 1000) for i in range(10)]</span><br><span class="line">    print(insert_sort(nums))</span><br></pre></td></tr></table></figure></p>
<h2 id="emsp-4-希尔排序"><a href="#emsp-4-希尔排序" class="headerlink" title="&emsp;4.希尔排序"></a>&emsp;4.希尔排序</h2><p>希尔排序是插入排序的一种.希尔排序按照下标的一定增量进行分组,对每组进行插入排序,随着增量(步长)减少,组数减少,直至只剩一组时,排序完成<br><img src="/2019/03/09/基本排序算法/shell_sort.gif" alt="shell_sort"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def shell_sort(nums):</span><br><span class="line">    n = len(nums)</span><br><span class="line">    # 分组， gap为组数(步长)</span><br><span class="line">    gap = n // 2</span><br><span class="line">    # 只剩一组时，排序完成</span><br><span class="line">    while gap &gt; 0:</span><br><span class="line">        # 对各组进行插入排序</span><br><span class="line">        for i in range(gap, n):</span><br><span class="line">            j = i</span><br><span class="line">            while j &gt;= gap and nums[j-gap] &gt; nums[j]:</span><br><span class="line">                nums[j], nums[j-gap] = nums[j-gap], nums[j]</span><br><span class="line">                j -= gap</span><br><span class="line">        # 重新分组，步长减小</span><br><span class="line">        gap //= 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    nums = [random.randint(0, 1000) for i in range(10)]</span><br><span class="line">    print(nums)</span><br><span class="line">    shell_sort(nums)</span><br><span class="line">    print(nums)</span><br></pre></td></tr></table></figure></p>
<h2 id="emsp-5-快速排序"><a href="#emsp-5-快速排序" class="headerlink" title="&emsp;5.快速排序"></a>&emsp;5.快速排序</h2><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列<br><img src="/2019/03/09/基本排序算法/quick_sort.jpg" alt="quick_sort"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def quick_sort(nums, start, end):</span><br><span class="line">    # 起始位置与终止位置相同时，该次排序完成</span><br><span class="line">    if start &gt;= end-1:</span><br><span class="line">        return</span><br><span class="line">    lo = start</span><br><span class="line">    hi = end-1</span><br><span class="line">    # 设起始位置为主元</span><br><span class="line">    mid = nums[lo]</span><br><span class="line">    # 将主元放置合适位置并排序，使主元左侧元素都比主元小，右侧元素都比主元大</span><br><span class="line">    while lo &lt; hi:</span><br><span class="line">        while lo &lt; hi and nums[hi] &gt; mid:</span><br><span class="line">            hi -= 1</span><br><span class="line">        nums[lo] = nums[hi]</span><br><span class="line">        while lo &lt; hi and nums[lo] &lt;= mid:</span><br><span class="line">            lo += 1</span><br><span class="line">        nums[hi] = nums[lo]</span><br><span class="line">    nums[lo] = mid</span><br><span class="line">    # 对两侧元素递归排序</span><br><span class="line">    quick_sort(nums, start, lo)</span><br><span class="line">    quick_sort(nums, lo+1, end)</span><br><span class="line">    return nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    nums = [random.randint(0, 1000) for i in range(10)]</span><br><span class="line">    print(nums)</span><br><span class="line">    print(quick_sort(nums, 0, len(nums)))</span><br></pre></td></tr></table></figure></p>
<h2 id="emsp-6-归并排序"><a href="#emsp-6-归并排序" class="headerlink" title="&emsp;6.归并排序"></a>&emsp;6.归并排序</h2><p>归并排序将数组分解至最小后(每组只剩一个元素),两两合并,比较大小排序,继续两两合并比较大小,直至合并为一个数组<br><img src="/2019/03/09/基本排序算法/merge_sort.gif" alt="merge_sort"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def merge_sort(nums_list):</span><br><span class="line">    if len(nums_list) &lt;= 1:</span><br><span class="line">        return nums_list</span><br><span class="line">    # 递归分解数组</span><br><span class="line">    middle = len(nums_list) // 2</span><br><span class="line">    nums1 = merge_sort(nums_list[:middle])</span><br><span class="line">    nums2 = merge_sort(nums_list[middle:])</span><br><span class="line">    # 递归合并数组并排序</span><br><span class="line">    return merge(nums1, nums2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def merge(nums1, nums2):</span><br><span class="line">    l1 = len(nums1)-1</span><br><span class="line">    l2 = len(nums2)-1</span><br><span class="line">    i = 0</span><br><span class="line">    j = 0</span><br><span class="line">    new_list = []</span><br><span class="line">    # 生成新的列表按升序存储两个子列表的元素</span><br><span class="line">    while i &lt;= l1 and j &lt;= l2:</span><br><span class="line">        if nums1[i] &lt; nums2[j]:</span><br><span class="line">            new_list.append(nums1[i])</span><br><span class="line">            i += 1</span><br><span class="line">        else:</span><br><span class="line">            new_list.append((nums2[j]))</span><br><span class="line">            j += 1</span><br><span class="line">    # 将剩余子列表的元素加入新列表</span><br><span class="line">    if i &gt; l1:</span><br><span class="line">        new_list += nums2[j:]</span><br><span class="line">    else:</span><br><span class="line">        new_list += nums1[i:]</span><br><span class="line">    return new_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    nums_list = [random.randint(0, 1000) for i in range(10)]</span><br><span class="line">    print(merge_sort(nums_list))</span><br></pre></td></tr></table></figure></p>
<h2 id="emsp-7-堆排序"><a href="#emsp-7-堆排序" class="headerlink" title="&emsp;7.堆排序"></a>&emsp;7.堆排序</h2><p>要理解堆排序,首先要理解什么是堆,什么是最大堆(最小堆).堆是一种完全二叉树,即除最底层,其它各层叶节点都达到最大个数.最大堆即为根节点的值都大于子节点的完全二叉树.堆排序的原理就是将数组构建为一个最大堆(数据结构类型不变,只变换元素位置),然后将根节点与数组最后一个元素交换位置,继续将除数组最后一个元素外的部分构建为最大堆,然后将根节点与数组倒数第二个元素交换位置,以此类推,直到每个元素都交换一次,即排序完成<br><img src="/2019/03/09/基本排序算法/heap_sort.gif" alt="heap_sort"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def max_heapify(heap, heap_size, root):</span><br><span class="line">    # 构建最大堆</span><br><span class="line">    left = root*2+1</span><br><span class="line">    right = left+1</span><br><span class="line">    larger = root</span><br><span class="line">    # 比较根节点与子节点的值，将最大的元素放于根节点</span><br><span class="line">    if left &lt; heap_size and heap[left] &gt; heap[larger]:</span><br><span class="line">        larger = left</span><br><span class="line">    if right &lt; heap_size and heap[right] &gt; heap[larger]:</span><br><span class="line">        larger = right</span><br><span class="line">    if root != larger:</span><br><span class="line">        heap[root], heap[larger] = heap[larger], heap[root]</span><br><span class="line">        max_heapify(heap, heap_size, larger)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def heap_sort(heap):</span><br><span class="line">    heap_size = len(heap)</span><br><span class="line">    # 对每个根节点都构建最大堆，从最底层开始</span><br><span class="line">    for root in range(heap_size//2-1, -1, -1):</span><br><span class="line">        max_heapify(heap, heap_size, root)</span><br><span class="line">    # 将根节点与数组最后元素交换位置</span><br><span class="line">    for i in range(heap_size-1, -1, -1):</span><br><span class="line">        heap[0], heap[i] = heap[i], heap[0]</span><br><span class="line">        # 堆剩余元素继续构建最大堆</span><br><span class="line">        max_heapify(heap, i, 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    heap = [random.randint(0, 1000) for i in range(10)]</span><br><span class="line">    print(heap)</span><br><span class="line">    heap_sort(heap)</span><br><span class="line">    print(heap)</span><br></pre></td></tr></table></figure></p>
<h1 id="线性时间排序"><a href="#线性时间排序" class="headerlink" title="线性时间排序"></a>线性时间排序</h1><h2 id="emsp-1-计数排序"><a href="#emsp-1-计数排序" class="headerlink" title="&emsp;1.计数排序"></a>&emsp;1.计数排序</h2><p>计数排序要求数组中的元素都为0到k中的某个元素(即数组中k为最大值),对于每个元素,计算小于等于该元素值的元素个数,根据这一信息,就可以将元素放到合适的位置.比如小于等于5的元素个数为3,5就可以放到索引为3的位置<br><img src="/2019/03/09/基本排序算法/counting_sort.gif" alt="counting_sort"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def counting_sort(nums, k):</span><br><span class="line">    # k为列表中最大元素</span><br><span class="line">    n = len(nums)</span><br><span class="line">    # 生成临时列表，元素值为小于等于该索引值的个数，临时列表的索引值与nums的元素值一一对应</span><br><span class="line">    tmp_list = [0 for i in range(k+1)]</span><br><span class="line">    # 生成存放已排序元素的列表</span><br><span class="line">    new_list = [0 for i in range(n)]</span><br><span class="line">    # 计算等于该元素值的元素个数，放入临时列表</span><br><span class="line">    for i in nums:</span><br><span class="line">        tmp_list[i] += 1</span><br><span class="line">    # 计算小于等于该元素值得元素个数（即将临时列表相邻元素值相加，比如小于5的元素个数为3，小于等于5的元素个数即为小于5的元素个数加上等于5的元素个数）</span><br><span class="line">    for i in range(1, k+1):</span><br><span class="line">        tmp_list[i] += tmp_list[i-1]</span><br><span class="line">    # 将排序好的元素放入合适的位置</span><br><span class="line">    for i in nums:</span><br><span class="line">        new_list[tmp_list[i]-1] = i</span><br><span class="line">        tmp_list[i] -= 1</span><br><span class="line">    return new_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    nums = [random.randint(0, 1000) for i in range(10)]</span><br><span class="line">    k = max(nums)</span><br><span class="line">    print(nums)</span><br><span class="line">    print(counting_sort(nums, k))</span><br></pre></td></tr></table></figure></p>
<h2 id="emsp-2-基数排序"><a href="#emsp-2-基数排序" class="headerlink" title="&emsp;2.基数排序"></a>&emsp;2.基数排序</h2><p>基数排序要求知道数组中最大元素的位数(如100是三位数),根据d位数进行d轮排序,每轮依次比较该位上的值,并排序,从最小位开始<br><img src="/2019/03/09/基本排序算法/radix_sort.gif" alt="radix_sort"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def radix_sort(nums, d):</span><br><span class="line">    for i in range(d):</span><br><span class="line">        # 生成临时容器，十进制数生成10个</span><br><span class="line">        tmp = [[] for i in range(10)]</span><br><span class="line">        # 依次按数位上值的大小放入临时数组</span><br><span class="line">        for j in nums:</span><br><span class="line">            tmp[j//(10**i)%10].append(j)</span><br><span class="line">        # 生成该轮次排序好的数组</span><br><span class="line">        nums = [j for i in tmp for j in i]</span><br><span class="line">    return nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    nums = [random.randint(0, 1000) for i in range(10)]</span><br><span class="line">    print(nums)</span><br><span class="line">    print(radix_sort(nums, 3))</span><br></pre></td></tr></table></figure></p>
<h2 id="emsp-3-桶排序"><a href="#emsp-3-桶排序" class="headerlink" title="&emsp;3.桶排序"></a>&emsp;3.桶排序</h2><p>桶排序假设数组服从均匀分布,然后生成n个桶(n为元素个数),将元素均匀放在各桶中,然后对每个通进行排序,最后将桶中元素合并<br><img src="/2019/03/09/基本排序算法/bucket_sort.jpg" alt="bucket_sort"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def insert_sort(nums_list):</span><br><span class="line">    for j in range(1, len(nums_list)):</span><br><span class="line">        cur = nums_list[j]</span><br><span class="line">        i = j-1</span><br><span class="line">        while i &gt;= 0 and nums_list[i] &gt; cur:</span><br><span class="line">            nums_list[i], nums_list[i+1] = nums_list[i+1], nums_list[i]</span><br><span class="line">            i -= 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def bucket_sort(nums):</span><br><span class="line">    n = len(nums)</span><br><span class="line">    # 生成n个桶</span><br><span class="line">    tmp_list = [[] for i in range(n)]</span><br><span class="line">    # 将元素均匀放在每个桶中</span><br><span class="line">    for i in nums:</span><br><span class="line">        tmp_list[int(i*n)].append(i)</span><br><span class="line">    # 对各桶元素进行插入排序</span><br><span class="line">    for l in tmp_list:</span><br><span class="line">        insert_sort(l)</span><br><span class="line">    nums = [j for i in tmp_list for j in i]</span><br><span class="line">    return nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    nums = [random.random() for i in range(100)]</span><br><span class="line">    print(nums)</span><br><span class="line">    print(bucket_sort(nums))</span><br></pre></td></tr></table></figure></p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p><img src="/2019/03/09/基本排序算法/sort.png" alt="复杂度"><br>根据合适的情况选择合适的排序算法<br>当待排序元素的关键字随机分布时,快速排序的平均时间最短<br>快速排序比堆排序和归并排序要快2到3倍<br>快速排序会出现最坏情况,快速排序是不稳定的<br>堆排序不会出现最坏情况<br>当待排序序列基本有序时,可以使用简单插入排序<br>归并排序是稳定的,但是需要一个同样大小的存储空间</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/排序/" rel="tag"># 排序</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/17/二叉树/" rel="prev" title="二叉树">
                二叉树 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">takerhythm</p>
              <p class="site-description motion-element" itemprop="description">personal blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#比较排序"><span class="nav-number">1.</span> <span class="nav-text">比较排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#emsp-1-冒泡排序"><span class="nav-number">1.1.</span> <span class="nav-text"> 1.冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emsp-2-选择排序"><span class="nav-number">1.2.</span> <span class="nav-text"> 2.选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emsp-3-插入排序"><span class="nav-number">1.3.</span> <span class="nav-text"> 3.插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emsp-4-希尔排序"><span class="nav-number">1.4.</span> <span class="nav-text"> 4.希尔排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emsp-5-快速排序"><span class="nav-number">1.5.</span> <span class="nav-text"> 5.快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emsp-6-归并排序"><span class="nav-number">1.6.</span> <span class="nav-text"> 6.归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emsp-7-堆排序"><span class="nav-number">1.7.</span> <span class="nav-text"> 7.堆排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线性时间排序"><span class="nav-number">2.</span> <span class="nav-text">线性时间排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#emsp-1-计数排序"><span class="nav-number">2.1.</span> <span class="nav-text"> 1.计数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emsp-2-基数排序"><span class="nav-number">2.2.</span> <span class="nav-text"> 2.基数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emsp-3-桶排序"><span class="nav-number">2.3.</span> <span class="nav-text"> 3.桶排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#复杂度"><span class="nav-number">3.</span> <span class="nav-text">复杂度</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">takerhythm</span>

  
</div>


  <div class="powered-by">  个人博客</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
